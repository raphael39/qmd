[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "This is my last summer semester 2024 at KIT",
    "section": "",
    "text": "Preface\nWelcome to my tale of survival during the summer semester of 2024 at the Karlsruhe Institute of Technology (KIT). This book is a collection of stories, mishaps, and the occasional epiphany that I encountered while navigating the chaos of deadlines, lectures, while working full time at an internship and way too much coffee. If you’re looking for inspiration, you might be in the wrong place—but if you want a good laugh at my expense, you’re definitely in the right one. Here’s to the ups, downs, and everything in between that made this semester unforgettable!",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "hoc.html",
    "href": "hoc.html",
    "title": "1  HOC",
    "section": "",
    "text": "1.1 Key Features\nHere are some of the key features of Quarto:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>HOC</span>"
    ]
  },
  {
    "objectID": "hoc.html#key-features",
    "href": "hoc.html#key-features",
    "title": "1  HOC",
    "section": "",
    "text": "Multi-format output: You can render your documents into multiple formats, including HTML, PDF, and EPUB.\nIntegrated Code: Quarto supports embedding code chunks in languages like Python, R, and Julia.\nMarkdown-based: Quarto uses Markdown, making it easy to write and format text.\nCross-references: Easily create cross-references for sections, figures, and tables.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>HOC</span>"
    ]
  },
  {
    "objectID": "hoc.html#example-of-a-code-chunk",
    "href": "hoc.html#example-of-a-code-chunk",
    "title": "1  HOC",
    "section": "1.2 Example of a Code Chunk",
    "text": "1.2 Example of a Code Chunk\nQuarto allows you to include code chunks directly in your document. Here’s an example using Python:\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1.1: A line plot on a polar axis",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>HOC</span>"
    ]
  },
  {
    "objectID": "hoc.html#tables",
    "href": "hoc.html#tables",
    "title": "1  HOC",
    "section": "1.3 Tables",
    "text": "1.3 Tables\nThe example table in the code displays a simple table with three columns. Each column contains the word “Data” repeated three times. The table is created using Markdown syntax, with each column separated by vertical bars (|). The table headers are specified in the first row, and the data is filled in subsequent rows.\n\n\n\nSemester 1\nSemester 2\nSemester 3\n\n\n\n\nFun\nTable\n!\n\n\nLet’s\nHave\nSome\n\n\nFun\nwith\nCode",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>HOC</span>"
    ]
  },
  {
    "objectID": "SE.html",
    "href": "SE.html",
    "title": "2  Software Evolution",
    "section": "",
    "text": "2.1 Version Control\nOne of the fundamental techniques in software evolution is version control. Version control systems, such as Git, enable developers to track changes made to the source code over time. By using version control, developers can easily collaborate, revert changes, and maintain a history of the software’s evolution.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software Evolution</span>"
    ]
  },
  {
    "objectID": "SE.html#refactoring",
    "href": "SE.html#refactoring",
    "title": "2  Software Evolution",
    "section": "2.2 Refactoring",
    "text": "2.2 Refactoring\nRefactoring is the process of restructuring existing code without changing its external behavior. It aims to improve the code’s readability, maintainability, and performance. Common refactoring techniques include extracting methods, renaming variables, and eliminating code duplication. By refactoring code, developers can make it easier to understand and maintain, leading to more efficient software evolution.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software Evolution</span>"
    ]
  },
  {
    "objectID": "SE.html#continuous-integration-and-deployment",
    "href": "SE.html#continuous-integration-and-deployment",
    "title": "2  Software Evolution",
    "section": "2.3 Continuous Integration and Deployment",
    "text": "2.3 Continuous Integration and Deployment\nContinuous integration (CI) and continuous deployment (CD) are practices that automate the process of building, testing, and deploying software changes. CI ensures that changes made by multiple developers are integrated regularly, reducing the chances of conflicts and enabling faster feedback. CD automates the deployment of software changes to production environments, allowing for rapid and frequent releases. These practices facilitate the evolution of software by enabling quick iterations and reducing the time between development and deployment.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software Evolution</span>"
    ]
  },
  {
    "objectID": "SE.html#testing",
    "href": "SE.html#testing",
    "title": "2  Software Evolution",
    "section": "2.4 Testing",
    "text": "2.4 Testing\nTesting is a crucial aspect of software evolution. It helps ensure that changes made to the software do not introduce new bugs or regressions. Different testing techniques, such as unit testing, integration testing, and acceptance testing, are used to validate the behavior and functionality of the software. By having comprehensive test suites, developers can confidently make changes to the software and ensure its stability and reliability.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software Evolution</span>"
    ]
  },
  {
    "objectID": "SE.html#documentation",
    "href": "SE.html#documentation",
    "title": "2  Software Evolution",
    "section": "2.5 Documentation",
    "text": "2.5 Documentation\nDocumentation plays a vital role in software evolution. It provides information about the software’s architecture, design decisions, and usage instructions. Well-documented software is easier to understand, maintain, and evolve. Techniques such as inline comments, code documentation, and user guides help developers and users navigate the software’s evolution and make informed decisions.\nIn conclusion, software evolution is a continuous process that involves various techniques to modify, improve, and maintain software over time. Version control, refactoring, continuous integration and deployment, testing, and documentation are some of the key techniques used in software evolution. By employing these techniques, developers can ensure the software’s adaptability, stability, and longevity.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software Evolution</span>"
    ]
  },
  {
    "objectID": "Numerik.html",
    "href": "Numerik.html",
    "title": "3  Numerik",
    "section": "",
    "text": "3.1 Root Finding\nOne important problem in numerical mathematics is finding the roots of a function. The root of a function is a value that makes the function equal to zero. There are several methods for root finding, such as the bisection method, Newton’s method, and the secant method.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Numerik</span>"
    ]
  },
  {
    "objectID": "Numerik.html#root-finding",
    "href": "Numerik.html#root-finding",
    "title": "3  Numerik",
    "section": "",
    "text": "3.1.1 Bisection Method\nThe bisection method is a simple and robust method for finding roots. It works by repeatedly dividing an interval in half and narrowing down the interval until a root is found. Here’s an example implementation in Python:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Numerik</span>"
    ]
  },
  {
    "objectID": "Numerik.html#upper-lower-matrix-method",
    "href": "Numerik.html#upper-lower-matrix-method",
    "title": "3  Numerik",
    "section": "3.2 Upper Lower Matrix Method",
    "text": "3.2 Upper Lower Matrix Method\nThe Upper Lower Matrix Method is a technique used to solve systems of linear equations. It involves decomposing a matrix into an upper triangular matrix and a lower triangular matrix. This decomposition allows for efficient and straightforward solutions to linear systems.\nTo illustrate the Upper Lower Matrix Method, let’s consider a system of linear equations: ## Die LR-Zerlegung\nDie LR-Zerlegung (auch LU-Zerlegung) ist eine Methode zur Zerlegung einer quadratischen Matrix in zwei Matrizen: eine untere Dreiecksmatrix L und eine obere Dreiecksmatrix R (oder U). Diese Methode wird häufig in der numerischen Mathematik zur Lösung von Gleichungssystemen, zur Inversion von Matrizen und zur Bestimmung der Determinante verwendet.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Numerik</span>"
    ]
  },
  {
    "objectID": "Numerik.html#definition",
    "href": "Numerik.html#definition",
    "title": "3  Numerik",
    "section": "3.3 Definition",
    "text": "3.3 Definition\nGegeben eine Matrix A, kann die LR-Zerlegung wie folgt geschrieben werden:\n\\[\nA = L \\cdot R\n\\]\nDabei ist:\n\nL eine untere Dreiecksmatrix mit Einsen auf der Diagonalen.\nR eine obere Dreiecksmatrix.\n\n\n3.3.1 Beispiel\nBetrachten wir eine Matrix A:\n\\[\nA = \\begin{pmatrix}\n2 & 3 & 1 \\\\\n4 & 7 & 2 \\\\\n6 & 18 & 5\n\\end{pmatrix}\n\\]\nDie LR-Zerlegung von A ergibt:\n\\[\nL = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n2 & 1 & 0 \\\\\n3 & 3 & 1\n\\end{pmatrix},\n\\quad\nR = \\begin{pmatrix}\n2 & 3 & 1 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Numerik</span>"
    ]
  },
  {
    "objectID": "Numerik.html#berechnung-der-lr-zerlegung",
    "href": "Numerik.html#berechnung-der-lr-zerlegung",
    "title": "3  Numerik",
    "section": "3.4 Berechnung der LR-Zerlegung",
    "text": "3.4 Berechnung der LR-Zerlegung\nDie LR-Zerlegung kann mit verschiedenen numerischen Verfahren berechnet werden. Eine der am häufigsten verwendeten Methoden ist der Gaußsche Eliminationsprozess.\n\n\nCode\nimport numpy as np\nfrom scipy.linalg import lu\n\n# Definieren der Matrix A\nA = np.array([[2, 3, 1],\n              [4, 7, 2],\n              [6, 18, 5]])\n\n# Durchführung der LR-Zerlegung\nP, L, U = lu(A)\n\nprint(\"L =\\n\", L)\nprint(\"R =\\n\", U)\n\n\nL =\n [[1.         0.         0.        ]\n [0.66666667 1.         0.        ]\n [0.33333333 0.6        1.        ]]\nR =\n [[ 6.         18.          5.        ]\n [ 0.         -5.         -1.33333333]\n [ 0.          0.          0.13333333]]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Numerik</span>"
    ]
  },
  {
    "objectID": "Rechnerstrukturen.html",
    "href": "Rechnerstrukturen.html",
    "title": "4  Rechnerstrukturen",
    "section": "",
    "text": "4.1 Definition\nRechnerstrukturen beziehen sich auf die Architektur und Organisation von Computern. Sie umfassen die verschiedenen Komponenten eines Computersystems, wie Prozessor, Speicher, Eingabe- und Ausgabegeräte sowie die Verbindungen zwischen ihnen.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Rechnerstrukturen</span>"
    ]
  },
  {
    "objectID": "Rechnerstrukturen.html#definition",
    "href": "Rechnerstrukturen.html#definition",
    "title": "4  Rechnerstrukturen",
    "section": "",
    "text": "4.1.1 Von-Neumann-Architektur\nDie Von-Neumann-Architektur ist eine der grundlegendsten Arten von Rechnerstrukturen. Sie besteht aus vier Hauptkomponenten:\n\nSpeicher: Speichert Daten und Programme.\nRechenwerk (ALU): Führt arithmetische und logische Operationen durch.\nSteuerwerk: Interpretiert Befehle und steuert die anderen Komponenten.\nEingabe-/Ausgabeschnittstellen: Ermöglichen die Interaktion mit dem Computer.\n\n\n\n\n\n\n\nNote\n\n\n\nDie Von-Neumann-Architektur ist besonders bekannt für ihre Einfachheit und die Tatsache, dass sowohl Programme als auch Daten im selben Speicher gespeichert werden.\n\n\n\n\n4.1.2 Harvard-Architektur\nDie Harvard-Architektur unterscheidet sich dadurch, dass sie separate Speicher für Programme und Daten verwendet, was parallele Datenverarbeitung erleichtert und die Effizienz erhöht.\n\n\n4.1.3 Diagramm: Datenfluss in einer einfachen Computerarchitektur\n\nProgram Memory (Programmspeicher) sendet Daten an die CPU.\nData Memory (Datenspeicher) sendet ebenfalls Daten an die CPU.\nDie CPU verarbeitet die Daten und sendet die Ergebnisse an die Ausgabe.\n\n\n\n4.1.4 Textdiagramm:\nProgram Memory –&gt; CPU Data Memory —–&gt; CPU | v Output",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Rechnerstrukturen</span>"
    ]
  },
  {
    "objectID": "Rechnerstrukturen.html#interaktive-visualisierung-mit-plotly",
    "href": "Rechnerstrukturen.html#interaktive-visualisierung-mit-plotly",
    "title": "4  Rechnerstrukturen",
    "section": "4.2 Interaktive Visualisierung mit Plotly",
    "text": "4.2 Interaktive Visualisierung mit Plotly\nimport plotly.express as px import pandas as pd\ndf = pd.DataFrame({ “x”: [1, 2, 3, 4, 5], “y”: [10, 15, 13, 17, 14], “z”: [“A”, “B”, “C”, “D”, “E”] })\nfig = px.scatter(df, x=“x”, y=“y”, text=“z”, title=“Interaktive Plotly Grafik”) fig.update_traces(marker=dict(size=12, color=“LightSkyBlue”), selector=dict(mode=‘markers’))\nfig.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Rechnerstrukturen</span>"
    ]
  },
  {
    "objectID": "next.html",
    "href": "next.html",
    "title": "5  Next",
    "section": "",
    "text": "Uni Zürich",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Next</span>"
    ]
  }
]